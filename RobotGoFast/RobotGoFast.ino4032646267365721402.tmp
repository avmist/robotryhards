enum Direction { FORWARD, BACKWARD };

// ====================================================
// Stepper
// ====================================================

class Stepper {

public:

  static const int enablePin;
  static const float stepsPerRevolution;
  static const float microsteps;
  static const float wheelDiameter; // In inches
  
private:

  const int stepPin;
  const int dirPin;
  const bool reversed;
  unsigned long lastUpdateTime; // In uS
  unsigned long stepCount; // In microsteps
  unsigned long delay; // In uS
  float speed; // In Inches / Second
  
  Direction direction;
  
  // Global stepper object pointer array, needed by the update static method
  static Stepper * steppers[2];

  static bool enabled;

public:

  // Constructors
  Stepper(int stepPin, int dirPin, bool reversed);

  // Methods
  void set(float speed, Direction direction);

  // Statics
  static void enableAll();
  static void disableAll();
  static void updateAll();

private:

  void update();

};

// Declare statics, see http://bit.ly/2oRM8vK
Stepper * Stepper::steppers[2];
bool Stepper::enabled = false;
const int Stepper::enablePin = 4;
const float Stepper::stepsPerRevolution = 200;
const float Stepper::microsteps = 8;
const float Stepper::wheelDiameter = 2.838; // In inches

// Constructors
Stepper::Stepper(int stepPin, int dirPin, bool reversed) : stepPin(stepPin), dirPin(dirPin), reversed(reversed) {

  // Initialize members
  stepCount = 0;
  speed = 0;
  direction = FORWARD;

  // Add to stepper index array
  static int stepperId = 0;
  Stepper::steppers[stepperId++] = this;

  // Set pin modes
  pinMode(dirPin, OUTPUT);
  pinMode(stepPin, OUTPUT);

}

// Statics
void Stepper::enableAll() {
  digitalWrite(enablePin, LOW);
  enabled = true;
}

void Stepper::disableAll() {
  digitalWrite(enablePin, HIGH);
  enabled = false;
}

void Stepper::updateAll() {

  steppers[0]->update();
  steppers[1]->update();
  
}

// Methods
void Stepper::update() {

  // Time calculations
  unsigned long t = micros();
  unsigned long dt = t - lastUpdateTime;

  
  
  
}

void Stepper::set(float speed, Direction direction) {
  
  this->speed = speed;
  this->direction = direction;

  // Calculate step delay
  
  // Speed = Distance / Time (Inches / Second)
  
  // Degree per Step = 360 / (stepsPerRevolution / microsteps)
  float degPerSec = 360.f / (stepsPerRevolution / microsteps);
  
  // Distance Per Step = wheelDiameter * 2 * M_PI * (Degree per Step / 360)
  float distPerStep = wheelDiameter * 2.f * M_PI * (degPerSec / 360.f);
  
  // Delay = speed * (1 / Distance Per Step)
  this->delay = speed * (1 / distPerStep);
  
}



// ====================================================
// LED
// ====================================================

class LED {

public:

  enum Color { RED = 0, GREEN = 1, BLUE = 2 };
  enum State { SOLID, BLINKING, OFF };

private:

  int pins[3];
  State states[3];
  unsigned long duration[3];
  unsigned long lastUpdateTime[3]; // In uS
  bool on[3];

  // Global stepper object pointer array, needed by the update static method
  static LED * leds[10];

public:

  // Constructors
  LED(int rPin, int gPin, int bPin);

  // Statics
  static void updateAll();

  // Methods
  void blink(Color color, unsigned long dur);
  void solid(Color color);
  void off(Color color);

private:

  void update();
  void toggle(Color color);
  
};

// Declare statics, see http://bit.ly/2oRM8vK
LED * LED::leds[10];

LED::LED(int rPin, int gPin, int bPin) {

  pins[0] = rPin;
  pins[1] = gPin;
  pins[2] = bPin;
  
  duration[0] = duration[1] = duration[2] = 0;
  on[0] = on[1] = on[2] = false;
  states[0] = states[1] = states[2] = LED::OFF;

  // Add to LED index array
  static int ledId = 0;
  LED::leds[ledId++] = this;

  // Set pin modes  
  pinMode(pins[0], OUTPUT);
  pinMode(pins[1], OUTPUT);
  pinMode(pins[2], OUTPUT);

  // Initial Values
  analogWrite(pins[0], 1023);
  analogWrite(pins[1], 1023);
  analogWrite(pins[2], 1023);
  
}

void LED::update() {

  // Time calculations
  unsigned long t = micros();
  unsigned long dt[3];
  
  dt[0] = t - lastUpdateTime[0];
  dt[1] = t - lastUpdateTime[1];
  dt[2] = t - lastUpdateTime[2];

  // Red
  if (states[LED::RED] == LED::BLINKING && on[LED::RED]) {

    // Check duration
    if (dt[LED::RED] > duration[LED::RED]) {
      toggle(LED::RED);
      lastUpdateTime[LED::RED] = t;
    }
    
  }
  // Green
  if (states[LED::GREEN] == LED::BLINKING && on[LED::GREEN]) {

    // Check duration
    if (dt[LED::GREEN] > duration[LED::GREEN]) {
      toggle(LED::GREEN);
      lastUpdateTime[LED::GREEN] = t;
    }
    
  }

  // Blue
  if (states[LED::BLUE] == LED::BLINKING && on[LED::BLUE]) {

    // Check duration
    if (dt[LED::BLUE] > duration[LED::BLUE]) {
      toggle(LED::BLUE);
      lastUpdateTime[LED::BLUE] = t;
    }
    
  }
  
}

void LED::updateAll() {

  leds[0]->update();
  
}

void LED::toggle(Color color) {

  if (on[color]) {
    on[color] = false;
    states[color] = LED::OFF;
    analogWrite(pins[color], 1023);
  } else {
    on[color] = true;
    analogWrite(pins[color], 0);
  }
  
}

void LED::blink(Color color, unsigned long dur) {

  states[color] = LED::BLINKING;

  if(!on[color]) {
    toggle(color);
  }
  
  duration[color] = dur;
  lastUpdateTime[color] = micros();
}

void LED::solid(Color color) {

  states[color] = LED::SOLID;

  if(!on[color]) {
    toggle(color);
  }
  
}

void LED::off(Color color) {

  states[color] = LED::OFF;

  if(on[color]) {
    toggle(color);
  }
  
}

// ====================================================
// Main Loop
// ====================================================

enum RobotState { IDLE, RUNNING_OK };
enum RobotState state = IDLE;

// Globals
const int ir0 = A0;
const int ir1 = A1;
const int ir2 = A2;
const int ir3 = A3;

Stepper leftMotor(0, 1, false);
Stepper rightMotor(2, 3, true);
LED led(13, 12, 11);

void setup() {

  analogWriteResolution(10);

  pinMode(Stepper::enablePin, OUTPUT);
  digitalWrite(Stepper::enablePin, HIGH);

  pinMode(ir0, INPUT);
  pinMode(ir1, INPUT);
  pinMode(ir2, INPUT);
  pinMode(ir3, INPUT);
  
  Serial.begin(9600);
  
}

void loop() {

  // Do HLTM

  // Do stepper update
  //Stepper::updateAll();

  LED::updateAll();

  // Do position update

  // Do debug output
  debug();
  
}

unsigned long lastStatusPing = 0;

void debug() {

  Serial.print(analogRead(ir0));
  Serial.print(" ");
  Serial.print(analogRead(ir1));
  Serial.print(" ");
  Serial.print(analogRead(ir2));
  Serial.print(" ");
  Serial.println(analogRead(ir3));

  
  if(state == IDLE && (micros() - lastStatusPing) > 500000) {
    led.blink(LED::GREEN, 250000);
    lastStatusPing = micros();
  }
  
}

